---
layout : post
---

As a software engineer, if i want to learn a new programming language then i'll start by doing a quick research about the compilation process then i'll classifying it as a statically compiled or dynamically compiled languages but suddenly there are transpiled languages. Uh okay, what is it actually?

So let's just say compiler, interpreter, and transpiler are just different types of compilation method. A compiler compiles a source code into a bytecode, an interpreter compiles and run a source code on the fly, and a transpiler compiles a source code into another source code. Here's come my brief explanation.

###Compiler

A compiler usually compiles our code into an understandable machine code or bytecodes. Once compiled into bytecodes, it will be difficult for us human to read it. These bytecodes can be divided into low level bytecode or high level bytecode. Low level bytecodes are generated by native compiler and high level bytecodes are generated by runtime compiler.

####Native Compiler

Think of native compiler as the Indian language of American continent. We know Indian is the native people of American continent and if we want to communicate with them then we need to speak with their language. The indian language is unique to themself as it's not widely used in other region.

Take a look at the following example.
{% highlight c %}
// hello.c
#include <stdio.h>

int main(void)
{
  printf ("Hello, world!\n");
  return 0;
}
{% endhighlight %}

```
$ gcc hello.c -o helloprog
$ ls
hello.c helloprog
$ ./hello
Hello, world!
```

I compiled the C code using gcc compiler on a x86_64 PC architecture debian linux machine which result is helloprog bytecode. It should run the bytecode successfully on that system. Can it run on PowerPC machine? No, because the bytecode is tied to PC x86 Architecture. Can it run on windows? No, because the operating system is different. So it must be able to run on other linux with same PC spec right? Maybe yes, only if that linux is 64 bit. It's complicated! Yes it is, that's why when we want to download a native application there are many available download option for different OS and different architecture. This is what we called a native application which bytecodes is native. 

####Runtime Compiler (xVM Compiler)

If we want speed then we can go by building a native application but it's tightly coupled with the machine it's being built by. So we need a more universal language like English, a more universal bytecodes for our program. One of the most popular runtime right now is Java Virtual Machine or JVM for short. 

Let's take a look.
{% highlight java %}
// Hello.java
class Hello {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
{% endhighlight %}

```
$ javac Hello.java
$ ls
Hello.java Hello.class
$ java Hello.class
Hello World
```

Instead of compiling our code into low level native bytecodes, it will be compiled to high level bytecodes or intermediate code. These bytecodes can be executed by passing it as the first argument of `java` command. The `java` command will create a new Java process or JVM instance and our intermediate code will be thrown into it. But of course the JVM itself is running on a real machine, so in the end our intermediate should be transformed into real machine readable code at some point of the process.

As long as there is JVM installed, our intermediate code should be run just fine on any OS and architecture.  


