<!DOCTYPE html>
<html lang="en">
	<head><meta charset="utf-8"></head>
		<title>RMX|7 - Romy Elmaco Blog</title>
		<meta name="viewport" content="width=device-width,initial-scale=1.0">
	
		<link href="/css/style.css" rel="stylesheet">
        <link href="/css/syntax-highlighting.css" rel="stylesheet">
	</head>
	
    <body>
	<div id="outerwrapper">
    
    <div id="header">
    <a href="/">
        <span class="title-a">RMX</span>
        <span class="title-b">|7</span>
    </a>
</div>



	<div id="nav">
	<ul>
		
			<li><a href="/">Home</a></li>
            
                
                    <li>/</li>
                
            
		
			<li><a href="/page/tech">Tech</a></li>
            
                
                    <li>/</li>
                
            
		
			<li><a href="/page/about">About</a></li>
            
                
                    <li>/</li>
                
            
		
			<li><a href="/page/project">Project</a></li>
            
		
	</ul>
</div>

    
    <div class="separator">
    <hr>
</div>


    <div id="container" class="content">
    <h5>
        <div class="post-info">May 19, 2015</div>
    </h5>
    <h1>Compiler Interpreter And Transpiler</h1>
    <div class="post-content">
       <p>As a software engineer, if i want to learn a new programming language then i'll start by doing a quick research about the compilation process then i'll classifying it as a statically compiled or dynamically compiled languages but suddenly there are transpiled languages. Uh okay, what is it actually?</p>

<p>So let's just say compiler, interpreter, and transpiler are just different types of compilation method. A compiler compiles a source code into a bytecode, an interpreter compiles and run a source code on the fly, and a transpiler compiles a source code into another source code. Here's come my brief explanation.</p>

<h3>Compiler</h3>

<p>A compiler usually compiles our code into an understandable machine code or bytecodes. Once compiled into bytecodes, it will be difficult for us human to read it. These bytecodes can be divided into low level bytecode or high level bytecode. Low level bytecodes are generated by native compiler and high level bytecodes are generated by runtime compiler.</p>

<h4>Native Compiler</h4>

<p>Think of native compiler as the Indian language of American continent. We know Indian is the native people of American continent and if we want to communicate with them then we need to speak with their language. The indian language is unique to themself as it's not widely used in other region.</p>

<p>Take a look at the following example.</p>

<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// hello.c</span>
<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Hello, world!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>


<pre><code>$ gcc hello.c -o helloprog
$ ls
hello.c helloprog
$ ./hello
Hello, world!
</code></pre>

<p>I compiled the C code using gcc compiler on a x86_64 PC architecture debian linux machine which result is helloprog bytecode. It should run the bytecode successfully on that system. Can it run on PowerPC machine? No, because the bytecode is tied to PC x86 Architecture. Can it run on windows? No, because the operating system is different. So it must be able to run on other linux with same PC spec right? Maybe yes, only if that linux is 64 bit. It's complicated! Yes it is, that's why when we want to download a native application there are many available download option for different OS and different architecture. This is what we called a native application which bytecodes is native.</p>

<p>Here is some languages that fall into this category.</p>

<blockquote><p>C, C++, Pascal, Cobol, Fortran</p></blockquote>

<h4>Runtime Compiler (xVM Compiler)</h4>

<p>If we want speed then we can go by building a native application but it's tightly coupled with the machine it's being built with. So we need a more universal language like English, a more universal bytecodes for our program. One of the most popular runtime right now is Java Virtual Machine or JVM for short.</p>

<p>Let's take a look.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Hello.java</span>
<span class="kd">class</span> <span class="nc">Hello</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Hello World&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>


<pre><code>$ javac Hello.java
$ ls
Hello.java Hello.class
$ java Hello.class
Hello World
</code></pre>

<p>Instead of compiling our code into low level native bytecodes, it will be compiled into high level bytecodes or intermediate code. These bytecodes can be executed by passing it as the first argument of <code>java</code> command. The <code>java</code> command will create a new Java process or JVM instance and our intermediate code will be thrown into it. But of course the JVM itself is running on a real machine, so in the end our intermediate should be transformed into real machine readable code at some point of the process.</p>

<p>As long as there is JVM installed, our intermediate code should run just fine on any OS and architecture. Scalability, is that you?</p>

<p>Here is some languages that fall into this category</p>

<blockquote><p>Java (JVM), Scala(JVM), Kotlin(JVM), C#.NET, VB.NET</p></blockquote>

<h3>Interpreter</h3>

<p>Now we talk about dynamically compiled language. Do not misinterpret it the same  as dynamically typed language. It's different! Here is why.</p>

<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// Java</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;Hello World&quot;</span><span class="o">;</span></code></pre></div>




<div class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># hello.rb</span>
<span class="k">def</span> <span class="nf">s</span> <span class="o">=</span> <span class="s2">&quot;Hello World&quot;</span>
<span class="nb">puts</span> <span class="n">s</span></code></pre></div>


<p>See the difference? In Java we need to strictly declare the type of our variable where in Ruby we did not. The <strong>typed</strong> in dynamically typed term means type of the variable. It's not how we type the keyboard when we code the program! Ruby does have interactive shell which can be used to run the code directly in it. Yes it's dynamic, but that's not what it mean by dynamically typed language.</p>

<p>Another name for this kind of conception is Duck Typing. If an object walk like a duck, swim like a duck, and whack like a duck then that object must be a duck. So on the above example the ruby runtime might think, "Oh, that object is surrounded by double quote and it consist majorily by alphabets then it must be a String !".</p>

<p>Then we can try to run it.</p>

<pre><code>$ ruby hello.rb
Hello World
$ ls
hello.rb
</code></pre>

<p>It doesn't create any bytecode file. The <code>ruby</code> command process the code then run it in one go. The interpreter translate our code into bytecode at the runtime. So the routine is read->translate->execute. That's why it's often said that interpreter program will never be as fast as the pre compiled one like Java because it will always one step slower. For a small program that may be true, but the performance of a large scale program depends on many factor such caching, indexing, database design, threading, pattern. In short, the Architectural Design is what most important to think about.</p>

<p>Some languages that fall into this category is</p>

<blockquote><p>Ruby, Python, PHP, Groovy(JVM based)</p></blockquote>

<h3>Transpiler</h3>

<p>No matter how good your architeture design is by using caching, indexing, or whatever fancy technique you're using, you'll soon hit the performance barrier of interpreter languages. In the end, you'll want the native performance but without sacrifying the versatily development of interpreter languages. Facebook has experienced it before and made a solution for it. They created a compiler which compiles PHP code into C++ code, the C++ code then compiles into bytecode and run in production environment.</p>

<p>I don't have access to facebook HPHPc compiler so let's use another transpiled language as an example. It's called coffeescript and it compiles into javascript. The lexical structure itself is a bit more rubyish, not really but nailed it.</p>

<div class="highlight"><pre><code class="language-coffee" data-lang="coffee"><span class="nv">s = </span><span class="s">&quot;Hello World&quot;</span>
<span class="nv">sayHello = </span><span class="nf">(s) -&gt;</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span></code></pre></div>


<pre><code>$ ls src
hello.coffee
$ coffee --compile --output lib/ src/
$ ls lib
hello.js
</code></pre>

<p>Here is the transpiling result</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">sayHello</span><span class="p">;</span>

<span class="nx">s</span> <span class="o">=</span> <span class="s2">&quot;Hello World&quot;</span><span class="p">;</span>

<span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">alert</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>
<span class="p">};</span></code></pre></div>


<p>When we're developing a large Javascript application, with the nature of javascript sooner or later your code will turn into chunks of spaghetti code. By using coffeescript, it will make the development easier and structured because of the more refined lexical structure. But here comes another problem, when the application hits production phase you'll end up with two set of codes and when an error occur, you need trace it on both files which will lead to maintenance nightmare. Transpiler is a double edged concept so use it wise. Even facebook ends up by creating their own VM called HHVM to overcome this issue (i'll cover it later).</p>

<p>Some of transpiled languages are</p>

<blockquote><p>coffeescript, typescript, SCSS, LESS, and a hybrid called Kotlin.</p></blockquote>

<h3>Conclusion</h3>

<p>Phew, such a long post really. I never thought i'll write this long. Actually there are topics that i want to cover here such like HHVM and Kotlin. But maybe next time. Just a taste from the devil though, kotlin is 100% interoptible with java and can be compiled to java bytecode or javascript.</p>

<p>Adios!</p>

    </div>
    
    <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'rmx7';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>




    <div class="separator">
    <hr>
</div>


    <div id="footer">
    <span>Designed by <a href="/">Romy Elmaco</a> &copy; 2015</span>
</div>

    
    </div>
    
    <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        
          ga('create', 'UA-62831411-1', 'auto');
          ga('send', 'pageview');
    </script>
    </body>
</html>

